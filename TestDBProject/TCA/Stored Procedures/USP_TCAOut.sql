
CREATE PROC TCA.USP_TCAOut
(
@ORDER_ID	INT
)
-------------------------------------------------------------------------------------- 
-- NAME:			[TCA].[USP_TCAOut]
-- 
-- NOTE:			BLOOMBERG TO TCA DEAGGREGATED FILE
-- 
-- AUTHOR:			VIPUL KHATRI
-- DATE:			21/03/2018
-------------------------------------------------------------------------------------- 
-- DESCRIPTION:		CREATE A FEED FROM BLOOMBERG TO CREATE A TCA DEAGGREGATED FILE
-- HISTORY:			
-- 22-03-2018		VIPUL KHATRI			DAP-1858      -- Initially this will be used to rec the current logic


AS

	BEGIN

	SET NOCOUNT ON

		IF OBJECT_ID('TEMPDB..#LEVELS') IS NOT NULL
				DROP TABLE #LEVELS

		IF OBJECT_ID('TEMPDB..#ORDERS_ALLOCATIONS') IS NOT NULL
				DROP TABLE #ORDERS_ALLOCATIONS

		CREATE TABLE #LEVELS (
				LVL             INT NULL,
				I_TSORDNUM      INT NULL,
				I_AGGRTO        INT NULL,
				ROOT_I_TSORDNUM INT NULL
		)

		CREATE TABLE #ORDERS_ALLOCATIONS (
				ROOT_I_TSORDNUM          INT            NULL,
				LVL                      INT            NULL,
				I_TSORDNUM               INT            NULL,
				C_ACCOUNT                VARCHAR(8)     NULL,
				C_BROKER                 VARCHAR(10)    NULL,
				C_SIDE					  VARCHAR(5)	 NULL,
				DECISION_DATE            DATETIME       NULL,
				SENT_TO_BROKER_DATE_TIME DATETIME       NULL,
				ORDER_QUANTITY           DECIMAL(18, 6) NULL,
				ALLOCATED_QUANTITY       DECIMAL(18, 6) NULL,
				ALLOCATED_BROKER_COM     DECIMAL(18, 6) NULL,
				ALLOCATED_BROKER_PRICE   DECIMAL(18, 6) NULL,
				C_CURRENCY               VARCHAR(3)     NULL
		)

		;
		WITH CHILDORDERS (I_AGGRFROM,
							I_AGGRTO,
							I_TSORDNUM,
							LVL)
				AS (
				SELECT DISTINCT
					I_AGGRFROM,
					I_AGGRTO,
					I_TSORDNUM,
					0 AS LVL
				FROM #T_BBG_TCA_TRADE_ORDERS_AUDIT WITH (NOLOCK)
				WHERE I_TSORDNUM IN (@ORDER_ID)
				AND I_AGGRTO IS NULL
				UNION ALL
				SELECT
					AUDT.I_AGGRFROM,
					AUDT.I_AGGRTO,
					AUDT.I_TSORDNUM,
					LVL + 1
				FROM #T_BBG_TCA_TRADE_ORDERS_AUDIT AS AUDT WITH (NOLOCK)
				INNER JOIN CHILDORDERS AS D
					ON AUDT.I_AGGRTO = D.I_TSORDNUM
				WHERE  AUDT.I_AGGRTO <> AUDT.I_TSORDNUM  -- WE COULD GET AN INFINITE RECURSION WITHOUT THIS CONDITION.
				)
		INSERT INTO #LEVELS (LVL,
		I_TSORDNUM,
		I_AGGRTO)
				SELECT DISTINCT
					LVL,
					I_TSORDNUM,
					I_AGGRTO
				FROM CHILDORDERS CO


		-- UPDATE ROOT LEVEL
		UPDATE L
		SET ROOT_I_TSORDNUM = L3.I_TSORDNUM
		FROM #LEVELS L
		CROSS JOIN (SELECT
				L2.LVL,
				L2.I_TSORDNUM,
				L2.I_AGGRTO
		FROM #LEVELS L2
		WHERE I_AGGRTO IS NULL) L3

		/*
		DEMONSTRATES 1-PASS CALCULATION OF CORE MEASURES AND STATIC DATA
		FURTHER PROCESSING WOULD BE REQUIRED TO ALIGN DATA INTO UNIFIED DATA AT AN ROOT ORDER, CHILD ORDER, ACCOUNT, BROKER LEVEL
		*/

		INSERT INTO #ORDERS_ALLOCATIONS (ROOT_I_TSORDNUM,
		LVL,
		I_TSORDNUM,
		C_ACCOUNT,
		C_BROKER,
		C_SIDE,
		DECISION_DATE,
		SENT_TO_BROKER_DATE_TIME,
		ORDER_QUANTITY,
		ALLOCATED_QUANTITY,
		ALLOCATED_BROKER_COM,
		ALLOCATED_BROKER_PRICE,
		C_CURRENCY)

				SELECT
					LVL.ROOT_I_TSORDNUM,
					LVL.LVL,
					AU.I_TSORDNUM,
					C_ACCOUNT,
					C_BROKER,
					C_SIDE,
					MIN((CASE
						WHEN C_EVENT IN ('SELL ORDER PRE ALLOCATED', 'BUY ORDER PRE ALLOCATED') THEN CAST(D_DATE AS DATETIME) + CAST(T_TIME AS DATETIME)
						ELSE NULL
					END))           AS DECISION_DATE,
					MIN((CASE
						WHEN C_EVENT IN ('E-SENT: ROUTED TO ELEC BRKR', 'M-WORK: ROUTED TO MANU BRKR', 'E-WORK: ELEC BRKR ACKED') THEN CAST(D_DATE AS DATETIME) + CAST(T_TIME AS DATETIME)
						ELSE NULL
					END))           AS SENT_TO_BROKER_DATE_TIME,
					SUM((CASE
						WHEN C_EVENT = 'ACTIVATED ORDER' THEN F_QUANTITY
						ELSE 0
					END))           AS ORDER_QUANTITY,
					SUM((CASE
						WHEN C_EVENT IN ('ORDER ALLOCATED','CORRECTED ALLOCATION') THEN F_QUANTITY
						WHEN C_EVENT = 'ALLOCATION CANCELLED' THEN F_QUANTITY * -1
						ELSE 0
					END))           AS ALLOCATED_QUANTITY,
					SUM((CASE
						WHEN C_EVENT IN ('ORDER ALLOCATED','CORRECTED ALLOCATION') THEN C_BCOM_VALUE
						WHEN C_EVENT = 'ALLOCATION CANCELLED' THEN C_BCOM_VALUE * -1
						ELSE 0
					END))           AS ALLOCATED_BROKER_COM,
					AVG((CASE
						WHEN C_EVENT IN ('ORDER ALLOCATED','CORRECTED ALLOCATION') THEN F_PRICE
						WHEN C_EVENT = 'ALLOCATION CANCELLED' THEN F_PRICE * -1
						ELSE 0
					END))           AS ALLOCATED_BROKER_PRICE,
					MIN(C_CURRENCY) AS C_CURRENCY
				FROM T_BBG_TCA_TRADE_ORDERS_AUDIT AU
				INNER JOIN #LEVELS LVL
					ON AU.I_TSORDNUM = LVL.I_TSORDNUM
				WHERE C_EVENT IN ('ACTIVATED ORDER', 'ORDER ALLOCATED', 'ALLOCATION CANCELLED', 'SELL ORDER PRE ALLOCATED', 'BUY ORDER PRE ALLOCATED', 'E-SENT: ROUTED TO ELEC BRKR', 'M-WORK: ROUTED TO MANU BRKR', 'E-WORK: ELEC BRKR ACKED','CORRECTED ALLOCATION')
				GROUP BY LVL.ROOT_I_TSORDNUM,
						LVL.LVL,
						AU.I_TSORDNUM,
						C_ACCOUNT,
						C_BROKER,
						C_SIDE
				ORDER BY LVL.ROOT_I_TSORDNUM, LVL.LVL, AU.I_TSORDNUM, C_ACCOUNT, C_BROKER

		DECLARE @MAX_LEVEL INT
		SET @MAX_LEVEL = (SELECT
				MAX(LVL)
		FROM #LEVELS)

		-- INSERT HIGHEST LEVEL ORDERS INTO #ORDER_FILLS
		INSERT INTO #ORDER_FILLS (ROOT_I_TSORDNUM,
		LVL,
		I_TSORDNUM,
		C_ACCOUNT,
		C_BROKER,
		C_SIDE,
		ORDER_QUANTITY,
		ALLOCATED_QUANTITY,
		REMAINDER,
		RATIO)
				SELECT DISTINCT
					A.ROOT_I_TSORDNUM,
					A.LVL,
					A.I_TSORDNUM,
					A.C_ACCOUNT,
					A.C_BROKER,
					C_SIDE,
					o.ORDER_QUANTITY,
					ALLOCATED_QUANTITY,
					O.ORDER_QUANTITY - A.ALLOCATED_QUANTITY           AS REMAINDER,
										   
					1                        AS RATIO
				FROM #ORDERS_ALLOCATIONS A
				INNER JOIN 
					(select ROOT_I_TSORDNUM, I_TSORDNUM, C_ACCOUNT, ORDER_QUANTITY, LVL
					FROM #ORDERS_ALLOCATIONS
					WHERE ORDER_QUANTITY > 0) o  -- Order level
				ON A.ROOT_I_TSORDNUM = o.ROOT_I_TSORDNUM
				AND A.I_TSORDNUM = o.I_TSORDNUM
				AND A.C_ACCOUNT = o.C_ACCOUNT
				AND A.LVL = o.LVL
				WHERE a.LVL = @MAX_LEVEL
				--AND ALLOCATED_QUANTITY > 0

		-- UPDATE ALLOCATED QUANTITY
		UPDATE OFS
							
		SET ALLOCATED_QUANTITY = CASE WHEN O.ALLOCATED_QUANTITY > 0 
				THEN O.ALLOCATED_QUANTITY * OFS.RATIO
				ELSE OFS.ALLOCATED_QUANTITY
			END,
			ORDER_QUANTITY = CASE WHEN OFS.ORDER_QUANTITY > 0 
				THEN OFS.ORDER_QUANTITY * OFS.RATIO
				ELSE O.ORDER_QUANTITY
			END
		FROM #ORDER_FILLS OFS
		INNER JOIN #ORDERS_ALLOCATIONS O
				ON OFS.ROOT_I_TSORDNUM = O.ROOT_I_TSORDNUM
				AND OFS.LVL = O.LVL
				AND OFS.I_TSORDNUM = O.I_TSORDNUM
				AND OFS.C_ACCOUNT = O.C_ACCOUNT
				AND OFS.C_SIDE = O.C_SIDE
				AND OFS.C_BROKER = O.C_BROKER
		WHERE OFS.LVL = @MAX_LEVEL
		AND		O.ALLOCATED_QUANTITY > 0

		-- UPDATE REMAINDER
		UPDATE OFS
		SET REMAINDER =
						CASE
							WHEN ORDER_QUANTITY > 0 AND
									ALLOCATED_QUANTITY > 0 THEN (ORDER_QUANTITY - ALLOCATED_QUANTITY)
							WHEN ORDER_QUANTITY > 0 AND
									ALLOCATED_QUANTITY = 0 THEN ORDER_QUANTITY
							ELSE 0
						END,
			I_TSORDNUMDESC = CAST(I_TSORDNUM AS VARCHAR) + ' - ' + C_ACCOUNT + ' - ' + C_BROKER
		FROM #ORDER_FILLS OFS
		WHERE OFS.LVL = @MAX_LEVEL

		-- DO WHILE LOOP TO GO DOWN THE LEVELS.
		DECLARE @LVL INT

		SET @LVL = @MAX_LEVEL - 1

		WHILE (@LVL >= 0)
		BEGIN

				-- INSERT ORDERS FROM HIGHER LEVEL
				INSERT INTO #ORDER_FILLS (ROOT_I_TSORDNUM,
				LVL,
				I_TSORDNUM,
				C_ACCOUNT,
				C_BROKER,
				C_SIDE,
				ORDER_QUANTITY,
				ALLOCATED_QUANTITY,
				REMAINDER,
				RATIO)

					SELECT
						OFS_HIGHER.ROOT_I_TSORDNUM AS ROOT_I_TSORDNUM,
						OFS_HIGHER.LVL - 1         AS LVL,
						T.I_AGGRTO                 AS I_TSORDNUM,
						OFS_HIGHER.C_ACCOUNT       AS C_ACCOUNT,
						CAST('' AS VARCHAR(100))   AS C_BROKER,
						OFS_HIGHER.C_SIDE		  AS C_SIDE,			
						OFS_HIGHER.REMAINDER       AS ORDER_QUANTITY,
						0                          AS ALLOCATED_QUANTITY,
						0                          AS REMAINDER,
						1                          AS RATIO
					FROM #ORDER_FILLS OFS_HIGHER
					INNER JOIN #LEVELS T
						ON OFS_HIGHER.LVL = T.LVL
						AND OFS_HIGHER.ROOT_I_TSORDNUM = T.ROOT_I_TSORDNUM
						AND OFS_HIGHER.I_TSORDNUM = T.I_TSORDNUM
					WHERE OFS_HIGHER.LVL = @LVL + 1

				-- INSERT NEW ORDERS AT THAT LEVEL
				INSERT INTO #ORDER_FILLS (ROOT_I_TSORDNUM,
				LVL,
				I_TSORDNUM,
				C_ACCOUNT,
				C_BROKER,
				C_SIDE,
				ORDER_QUANTITY,
				ALLOCATED_QUANTITY,
				REMAINDER,
				RATIO)
					SELECT DISTINCT
						A.ROOT_I_TSORDNUM,
						A.LVL,
						A.I_TSORDNUM,
						A.C_ACCOUNT,
						CAST('' AS VARCHAR(100)) AS C_BROKER,
						C_SIDE,
						ORDER_QUANTITY,
						ALLOCATED_QUANTITY,
						0                        AS REMAINDER,
						1                        AS RATIO
					FROM #ORDERS_ALLOCATIONS A
					WHERE LVL = @LVL
					AND ORDER_QUANTITY > 0


				-- UPDATE RATIO FOR MULTIPLE ACCOUNTS BY ORDER NUM 
				;
				WITH ACCOUNTS_REQUIRING_RATIOS
					AS (SELECT
						O.I_TSORDNUM,
						O.C_ACCOUNT,
						LVL,
						COUNT(1) ACCOUNT_COUNT
					FROM #ORDER_FILLS O
					WHERE O.LVL = @LVL
					GROUP BY O.I_TSORDNUM,
							O.C_ACCOUNT,
							LVL
					HAVING COUNT(1) > 1),
					ACCOUNT_QUANTITY
					AS (SELECT
						OFS.I_TSORDNUM,
						OFS.C_ACCOUNT,
						OFS.LVL,
						SUM(OFS.ORDER_QUANTITY) ORDER_QUANTITY
					FROM #ORDER_FILLS OFS
					INNER JOIN ACCOUNTS_REQUIRING_RATIOS AR
						ON OFS.I_TSORDNUM = AR.I_TSORDNUM
						AND OFS.C_ACCOUNT = AR.C_ACCOUNT
						AND OFS.LVL = AR.LVL
					GROUP BY OFS.I_TSORDNUM,
							OFS.C_ACCOUNT,
							OFS.LVL)
				UPDATE OFS
				SET RATIO = OFS.ORDER_QUANTITY / AQ.ORDER_QUANTITY
				FROM #ORDER_FILLS OFS
				INNER JOIN ACCOUNT_QUANTITY AQ
					ON OFS.I_TSORDNUM = AQ.I_TSORDNUM
					AND OFS.C_ACCOUNT = AQ.C_ACCOUNT
					AND OFS.LVL = AQ.LVL

				-- UPDATE ALLOCATED QUANTITY
				UPDATE OFS
				SET C_BROKER = O.C_BROKER,
					ALLOCATED_QUANTITY = CASE WHEN O.ALLOCATED_QUANTITY > 0 
											THEN O.ALLOCATED_QUANTITY * OFS.RATIO
											ELSE OFS.ALLOCATED_QUANTITY
										END
				FROM #ORDER_FILLS OFS
				INNER JOIN #ORDERS_ALLOCATIONS O
					ON OFS.ROOT_I_TSORDNUM = O.ROOT_I_TSORDNUM
					AND OFS.LVL = O.LVL
					AND OFS.I_TSORDNUM = O.I_TSORDNUM
					AND OFS.C_ACCOUNT = O.C_ACCOUNT
				WHERE 	OFS.LVL = @LVL
				-- AND O.ALLOCATED_QUANTITY > 0

				-- UPDATE REMAINDER
				UPDATE OFS
				SET REMAINDER =
							CASE
									WHEN ORDER_QUANTITY > 0 AND
										ALLOCATED_QUANTITY > 0 THEN (ORDER_QUANTITY - ALLOCATED_QUANTITY)
									WHEN ORDER_QUANTITY > 0 AND
										ALLOCATED_QUANTITY = 0 THEN ORDER_QUANTITY
									ELSE 0
							END,
					I_TSORDNUMDESC = CAST(I_TSORDNUM AS VARCHAR) + ' - ' + C_ACCOUNT + ' - ' + C_BROKER
				FROM #ORDER_FILLS OFS
				WHERE OFS.LVL = @LVL

				SET @LVL = @LVL - 1

		END

		-- ROUND REMAINDER FOR LEVEL 0
		UPDATE OFS
		SET REMAINDER = ROUND(REMAINDER, 0)
		FROM #ORDER_FILLS OFS
		WHERE LVL = 0

	END